#Author: Robert Petit
#Project: WordleAnalysis

#-------------------------- Functions -----------------------


Gen_WordSet <- function(WordList) {
  #WordList should be a single column, named Word, of words. This will only parse for 5 letter words
  #Return is a DF with format [Word, Letter_1:Letter_5, UniqueLetters]
  WordSet = WordList %>% 
    filter(length(Word) != 5) %>%
    distinct %>%  #These two are good in practice, but unnecessary here since our list is correct
    mutate(Word = str_to_lower(Word),
              Letter_1 = str_sub(Word, 1, 1),
              Letter_2 = str_sub(Word, 2, 2),
              Letter_3 = str_sub(Word, 3, 3),
              Letter_4 = str_sub(Word, 4, 4),
              Letter_5 = str_sub(Word, 5, 5),) %>% 
    rowwise(Word) %>% #the dreaded rowwise operation. We need to perform a complex function on each row.
    #For reference, if you simply omit rowwise(), each row has /all/ of the unique letters from /every/ word in it. Neat
    mutate(UniqueLetters = Word %>% strsplit("") %>% unlist %>% unique %>% str_c(collapse=""))
  return(WordSet)
}

Gen_LetterInfo <- function(WordSet) {
  #Wordset should have the format [Word, Letter_1:Letter_5, UniqueLetters]
  #This is unexpectedly heavy because it is 26*(Words)*5 operations. Actually takes quite a second.
  #When run, if a parallel backend is registered, this will work
  
  Alphabet = "abcdefghijklmnopqrstuvwxyz" %>% strsplit("") %>% unlist
  LetterInfo = foreach(Letter=Alphabet, .combine="rbind") %dopar% {
    #We loop through every letter in the alphabet and generate the following information
    #If it is in the word at all
    #If it is in a given place
    REP_WordScore = WordSet %>%
      rowwise(Word) %>%
      mutate(InScore = ifelse(Letter %in% (UniqueLetters %>% strsplit("") %>% unlist), 1, 0),
             PlaceMatch_1 = ifelse((Letter==Letter_1), 1, 0),
             PlaceMatch_2 = ifelse((Letter==Letter_2), 1, 0),
             PlaceMatch_3 = ifelse((Letter==Letter_3), 1, 0),
             PlaceMatch_4 = ifelse((Letter==Letter_4), 1, 0),
             PlaceMatch_5 = ifelse((Letter==Letter_5), 1, 0))
    
    #Then we rbind it as a row and cast it to a df
    c(L=Letter, Match=sum(REP_WordScore$InScore),
      PM_1 = sum(REP_WordScore$PlaceMatch_1),
      PM_2 = sum(REP_WordScore$PlaceMatch_2),
      PM_3 = sum(REP_WordScore$PlaceMatch_3),
      PM_4 = sum(REP_WordScore$PlaceMatch_4),
      PM_5 = sum(REP_WordScore$PlaceMatch_5))
    
  } %>% as.data.frame
  return(LetterInfo)
}

#-------------------------- Clean Data -----------------------

#Words5 is a list of (almost) all 5 letter words in english generated by running 
#perl -nle 'print if /^[a-z]{5}$/' /usr/share/dict/words > Words5.txt
#on a unix-based system.

#SGB_Words is from the Sanford GraphBase list of common 5 letter words
#It is much shorter, but also more reasonable in useage than Words5
#Source: https://github.com/charlesreid1/five-letter-words/blob/master/sgb-words.txt


Words5_WordSet = read.delim(here("Data/Words5.txt"), header=F) %>% rename(Word = V1) %>% Gen_WordSet
SGB_Words_WordSet = read.delim(here("Data/SGB_Words.txt"), header=F) %>% rename(Word = V1) %>% Gen_WordSet

cl <- parallel::makeCluster(2)
doParallel::registerDoParallel(cl)

Words5_Letters = Gen_LetterInfo(Words5_WordSet)
SGB_Words_Letters = Gen_LetterInfo(SGB_Words_WordSet)
  
parallel::stopCluster(cl)


write.csv(Words5_WordSet, here("Data/Words5_WordSet.csv"), row.names=FALSE)
write.csv(Words5_Letters, here("Data/Words5_LetterInfo.csv"), row.names=FALSE)
write.csv(SGB_Words_WordSet, here("Data/SGB_Words_WordSet.csv"), row.names=FALSE)
write.csv(SGB_Words_Letters, here("Data/SGB_Words_LetterInfo.csv"), row.names=FALSE)
